문제를 보자마자 든 생각
3잔 연속으로 마실수없다
그럼 3번째잔을 마실수있냐 없냐가 첫 분기같다

		*
1	2	3	4	5	6
		
그렇다면 가장 많은양을 담은 포도주를 먼저 놔야할까?

6	10	13	9	8	1
순서의 포도주가 있다고 치자
일단 6을 마시면 10을 마시고 안마시고 선택할수있다
만약 여기서 10을 마시면 13을 못마시게 되고
10을 안마시면 13을 마실수 있게 된다.
최대값을 기준으로 따지기 때문에
6을 마신 후 10을마시는게 아닌 13을 마시도록 한다.
현재 6 - 13을 마셨다.

이제 새로운 포도주를 마셔야한다.
13을 마셨으니 이 다음포도주를 마실수 있는지 확인해야한다
만약 13 이전의 포도주를 마셨다면 다음것도 마신다면 연속으로 마시는것이기에
바로다음 포도주는 마시지 못한다.
하지만 우리는 13 이전의 포도주를 마시지 않았기 때문에
첫잔부터 마시는것처럼 계산하면 된다.
13 다음의 9와 13 다다음의 8중 하나를 선택해야 하는데
우리는 이중 가장 큰 값을 마시면 된다.
그러면 6 - 13 - 9를 마시게 된다.
이 때 우리는 3번연속 못마시는 조건때문에 1밖에 못마시게 된다.
즉 6 - 13 - 9 - 1 의 순서가 만들어지고 합은 29이다.
그렇다면 진짜 최대값은 먼지 손수계산해보자
진짜 최대값은 6 - 10 - 9 - 8 의 순서의 합인 33이다.
즉 위 계산법은 틀린것이다.

뭐가 틀렸을지 한번 생각해보자.
1. 1번째 잔을 고정시에 3번째잔을 마실수 있냐 없냐가 첫 분기가 아니다. 
2번째잔을 마실 차례에 2번째잔과 3번째잔중 뭘 마셔야할지 정하는게
첫번째 분기점이다.
2. 첫번째잔을 먼저 마셨다고 고정을 해야되나라는 생각이 조금 든다.
예를 들어 1 7 1 3 7 100 의 순서가 있다고 한다.
첫번째 잔을 고정한 채 위 계산법을 사용하게 되면
1 - 7 - 3 - 7 의 순서로 18이 값이 되고
실제 계산했을때 최대 값은 7 - 7 - 100 의 순서를 가진 114가 최대값이다.
이걸 파악할 수 있는 방법이 있을까?

2번째 생각
1	7	1	3	7	100
일단 몇 번을 마시는지가 최대가 아니라 얼마나 많은양을 마시는지를 구하는게 목표다.
처음 시작할때 값을 고정하지않고 첫번쨰와 두번째 중 값이 큰걸 기준으로 생각해볼까?
1과 7중 최대값은 7이다
7부터 다시 계산할때
1과 3중 최대값은 3이다
7 - 3
3부터 시작할때 7과 100중 최대값은 100이다
7 - 3 - 100
이래도 최대값이 안나온다.
이건 좀 그리디적 알고리즘 아닌가 싶다.

3번째 생각
다시 1		7	1	3	7	100이 있다고 해보자.
만약 3개씩 끊어서 생각하면 어떻게될까?
1 7 1중 최대값은 7이다
3 7 100 중 최대값은 100이다
7 - 100 = 107임으로 이것도 아니다

4번째 생각
생각을 좀 바꿔서 첫번째부터 계산을 할게 아니라
뒤에서부터 계산해보면 어떨까
일단 똑같이 3개로 나누어 계산한다고 가정했을떄
예를들어 1 7 1이 있다고할때
마지막값인 1이 최대값인지 이 전값이 최대값인지 이 전전이 최대값인지 찾아보자
아니다 이거 아닌거같다

5번쨰 생각
위에 개념에서 조금 추가해보자
뒤에서부터 계산한다는 말이 틀린거같다
3개의 잔이 있을때 이 3개를 마시는 모든 경우의 수 중 최대를 구해보는게 맞는거같다
예를들어 위와같이 1	7	1	3	7	100 이 있다고 할때
첫번째 3개인 1	7	1을 가지고 비교해보자
이때 마실수 있는 경우의수는
1잔만 마실때
첫번째, 두번째, 3번째 이 3가지 경우가 있다.
2잔만 마실경우는
1-2, 2-3, 1-3 이 3가지 경우가 있다.
이 모든 경우의 수중 최대값을 구하자면
1-2 또는 2-3의 순서인 8이 최대값이다.
이 값은 결국 2잔을 마셨을때 최대값이다
즉	1	7	1 3개의 잔이 있는 상태에서 최대로 마실수 있는 양이
8이라는것이다.
그럼 이건 dp[3] = 8이라는 값이 된다.
근데 이런상태면 dp[1]과 dp[2]는 뭘까?
dp[1]은 포도주가 1개인 상태에서의 최대값이기에
무조건 한잔밖에 마실수 없고
dp[1] = 1이 된다.
그럼 dp[2]는 조건이 몇개 발생한다.
1	7이 있는 경우에서의 최대값이므로
무조건 둘 다 마신값이 최대값이다.
그럼 dp[2] = 8이 된다.
근데 dp[2]를 이런방식으로 하게되면 dp[3]과 값이 같아지는 문제가 생긴다
즉 dp[3]은 3번째 포도주를 못마시는 경우라는 것이다.
이게... 맞나?
그럼 dp[4]를 구해보자
포도주순서는	1	7	1	3이다.
dp안에 들어있는 값의 순서는
1	8	8	?이고
포도주의 양 순서는
1	7	1	3 이다.
이제부터는 점화식이 슬슬 나와야하니까
그냥 계산했을때 최대값부터 생각해보고 시작해보자
이떄 최대값은 1-7-3의 순서를 가진 11이 최대값이다.
아까 dp[2]가 나올수 있는 경우가 2가지였어서 점화식구하기 애매하다

6번째 생각
그냥 백준에서 나온 예시로 한번 생각해보자
6	10	13	9	8	1 의 순서로 있다치자
dp[1] = 6
dp[2] = 16
dp[3] = 23 (10 - 13)
dp[4] = 28 (6-13-9)
이때 나올수 있는 경우의수
6-10-9
6-13-9
10-13
당연히 최대값은 6-13-9의 값인 28이다
이거 이렇게 계산하니까 첫번째 생각이랑같은거같기도...
근데 dp[3]에서 dp[4]로 넘어갈때 순서가 바뀐다
머 당연한건데..
일단 다음거도 구해보자
dp[5] = 32 (6-10-9-8)
dp[6] = 32 (6-10-9-8) 똑같다...
결과
6	10	13	9	8	1
dp[1] = 6
dp[2] = 16
dp[3] = 23 (10 - 13)
dp[4] = 28 (6-13-9)
dp[5] = 32 (6-10-9-8)
dp[6] = 32 (6-10-9-8)
일단 선택결과들을 순서대로 표로 만들어보자
6	10	13	9	8	1
*
	*	*
*		*	*
*	*		*	*
*	*		*	*
머지시바알
규칙을 못찾겠다.
혹시 그러면 결과값인 dp를 기준으로 결과를 찾는게 아닐까/
다른 먼가를 더해줘야 점화식이 되는건가
dp만으로 점화식을 구할수가 없는건가

7번째 생각
일단 다른값을 더해줘야한다고 생각해보자
dp말고 다른값으로 더해줄수 있는건 원래 포도주의 양을 더할수있을거다.
일단 위의 기준으로 생각해보자
일단 값들을 좀 정의해주자
포도주양(pa)
6	10	13	9	8	1
결과저장(dp)
6	16	23	28	32	32
일단 이거만 보고 단순하게 생각해보자
순서들이 순차적으로 커지는게 아니다
그렇다면 무언가의 최대값을 기준으로 더해준다는 생각은 맞는거같다.
그럼 어떤것의 최대값을 더해준다고 생각해야할까?
아니다
dp[n]과 d[n-1]이 같은 경우가 있기때문에 더한다는 생각은 잘못된거같다
점화식이 여러개가 있고 그 점화식들간의 최대값이 dp[n]이 되는거같다
그럼 일단 dp[n]과 d[n-1]이 같을경우가 있기 때문에
최대값을 구하는 부분에 dp[n-1]은 들어가야한다.
그럼 다른 점화식들은 뭐가있을까?
근데 왜 본능적으로 점화식들이라고했지?
점화식이 2개일수도있잖아
dp[n-1]과 다른점화식 하나 이렇게해서
dp[n-1]도 점화식으로 볼수 있으니까?
일단 다른걸 생각해보자
일단 뒤에서부터 생각해보자
역순으로
dp[6] = 32 (6-10-9-8)
dp[5] = 32 (6-10-9-8)
dp[4] = 28 (6-13-9)
dp[3] = 23 (10 - 13)
dp[2] = 16
dp[1] = 6
이런 순서가 되었을때
일단 중복되는dp[6]은 빼보자
dp[5] = 32 (6-10-9-8)
dp[4] = 28 (6-13-9)
이 두개를 비교해보자
일단 순서만 봐보자
동일순서가 있다 6-10-9
근데 또 아래로 내려가다보면 동일순서가 안나올때도있네
일단 순서로따지는건 아닌거같다.
일단 선택배열순서표 만들어놓은거로 봐야겠다
6	10	13	9	8	1
*
	*	*
*		*	*
*	*		*	*
*	*		*	*
잠깐만
3잔을 마실때
연속되는
머
잠깐만?
아
기준이 3잔
3잔기준이 규칙인가
아
3잔이 있을때 마실수 있는 경우의수가아니라
내가 지금 마시려는 잔이 몇번째 잔인가를 생각해보면되나?
예를들어 위의 값
6	10	13	9	8	1
dp[6] = 32 (6-10-9-8)
dp[5] = 32 (6-10-9-8)
dp[4] = 28 (6-13-9)
dp[3] = 23 (10 - 13)
dp[2] = 16
dp[1] = 6
이 경우에서
n번째인 1의 양을 가진 잔을 안마셔서
dp[6]과 dp[5]가 같은거잖아
dp[5]는 연속으로 마신게 몇개지?
6-10-9-8에서 9-8이 연속되는 잔이다
그래서 dp[6]을 마실수가 없던거고?
즉 dp[6]는 연속으로3번째 잔이 되는것이기에 마실수 없던거다
즉 연속으로 마실수 없는 경우다
연속으로마실수없는 경우가 dp[n-1]이다?
그럼 만약에 연속으로 마실수 있는 경우는?
n이 연속으로 마실수 있는 경우의수는머지?

8번째 생각
마지막으로 생각 정리를 해보자
포도주는 3잔 연속으로 마실 수 없다
1 2 3이 있다고 했을때
n을 3이라고 생각하고
마실수있는 경우의 수를 생각해보자
1	2	3
*		*
	*	*
*	*	
이 3가지 경우다
순서로 하면
1-3, 2-3, 1-2가 된다.
아까 우리가 구했던 dp[n] = dp[n-1]은 연속으로 마실수 없는경우
즉 1-2의 경우가 dp[n-1]이 된다.
그럼 나머지 1-3, 2-3은?
1-3의 경우는 pa[1]+pa[3]이다.
2-3의 경우는 pa[2]+pa[3]이다.
근데 위의 두 경우는
그냥 값만 넣은거기때문에
1보다 이전순서에 있는 결과 + 위의 합을 더해야할거다
그럼 점화식이 3개나오네?
1-3 => dp[n-3] + pa[n-2]+pa[n]
2-3 => dp[n-3] + pa[n-1]+pa[n]
1-2 => dp[n-1]
그럼 이 3개의 최대값이 dp[n]이다!!!!!!
근데 생각해보니까
dp[n-3]이 나오려면
dp[n]은 무조건 3보다 커야할거같은데?
그럼 dp를 구하는 반복문에
i = 3부터 해주면 되겠다.
그러면 반복문이 반복되면서
dp[1]과 dp[2]를 훑고지나갈텐데
이때 값은 머지그럼?
dp[1]은 그냥  pa[1]하면 될거같고
dp[2]는 어케하지?
dp[2]가 될수있는 경우의수는
pa[2]랑 pa[1]+pa[2]중 하나가 될거같은데
근데 사실 점화식이 최대값구하는거니까
나중에 나올값이 저 두개중 머가됐든간에 크거나 같을테니까
아무거나 해도 상관없을거같다.
걍 pa[2]로 해야겠다.
##############틀렸다

9번째 생각
문제에 사용한 코드는 이러하다
		int[] dp = new int[n+1];
		// dp[1]과 dp[2]는 pa로 초기화해준다
		dp[1] = pa[1];
		dp[2] = pa[2];
		// 3부터 해준다
		for (int i = 3; i <= n; i++) {
			dp[i] = Math.max(dp[i-1], Math.max(dp[i-3]+pa[i-2]+pa[i], dp[i-3] + pa[i-1]+pa[i]));
		}
		System.out.println(dp[n]);
dp안에는 
[0, 6, 10, 23, 28, 31, 33]이 들어가있었고
pa안에는
[0, 6, 10, 13, 9, 8, 1]이 들어가있었다.
점화식이 뭐가틀렸을까
1-3 => dp[n-3] + pa[n-2]+pa[n]
2-3 => dp[n-3] + pa[n-1]+pa[n]
1-2 => dp[n-1]
이게 원본점화식인데
멍청한짓했다.
1	2	3
*		*
	*	*
*	*	
이 3가지 경우에서 나올수 있는 점화식이란 3잔을 연속으로 마시는지가 중요한데
2-3 => dp[n-3] + pa[n-1]+pa[n]
1-2 => dp[n-1]
위 두가지는 맞다
근데 1-3의 경우는 다르다
1-3의 경우는 내가 첫번째로 n번째 포도주를 마신다는 경우다
일단 pa[n]]을 더해주는건 맞다
근데 dp[n-3]이 아니라 dp[n-2]가 되어야한다.
1-3의 경우와 2-3의 경우는
내가 연속으로 마시기 이전의 최대값 + 내가 연속으로 마실경우의 값을 더해주는 점화식이다.
즉 한턴 쉬는 저 빈칸 이전의 최대값, 즉 dp[n-2]가 되어야한다.
결과적으로
1-3 => dp[n-2] + pa[n]
2-3 => dp[n-3] + pa[n-1]+pa[n]
1-2 => dp[n-1]
이 되어야 맞다.
근데 값이 틀렸다고나온다.
점화식은 맞는데 dp의 배열이 [0, 6, 10, 23, 28, 31, 32]이 나온다.
혹시 dp[2]의 값을 pa[2]로 준게 문젠가 싶어서 pa[1]+pa[2]로 해줬더니 맞게나온다.
생각해보니 당연히 최대값을 넣는게 맞는거네 ㅋ 뭔생각한거냐 대체
근데 마지막에 런타임에러가나네?
머지
머지
배열범위초과?
머냐?
머지
머때문이지
흐음
for (int i = 1; i < pa.length; i++)를
for (int i = 1; i <= n; i++) 이렇게 수정해주니 또 범위초과네
머냐
아
혹시
dp[1]인 경우랑 dp[2]인 경우에도 반복문해줘서그런가?
아니네
머지
아 (1 ≤ n ≤ 10,000) 이니까 조건이 1보다 커야하는거구나
맞았다~~~~~~











